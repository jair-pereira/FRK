# parcing syntax: "<__>" - non-terminals, "{::}" - new line, "{:_____:}" - indentation

# Initialization, no branching
<S> ::= <init>{::}<call>

<init> ::= import numpy as np{::}from metaheuristic import *{::}def ge(n, my_func, bounds, dimension, max_nfe):{:Solution.setProblem(my_func, bounds, dimension, maximize=False){::}Solution.repair = <repair>{::}X = Solution.initialize(n){::}for Xi in X:    Xi.setX(op.init_random(*Solution.bounds, Solution.dimension)){::}[Xi.getFitness() for Xi in X]{::}Solution.updateHistory(X){::}while Solution.nfe < max_nfe and not my_func.final_target_hit:{:{::}U = X{::}<main>{::}[Xi.getFitness() for Xi in X]:}{::}return Solution:}{::}

# BRANCHING STARTS HERE
# main
<main> ::= <round>|<round>{::}'#Round Drop'{::}<drop>

<round> ::= '#Round 1'{::}<last_step>|
			'#Round 1'{::}<step>{::}'#Round 2'{::}<last_step>|
			'#Round 1'{::}<step>{::}'#Round 2'{::}<step>{::}'#Round 3'{::}<last_step>

<last_step> ::= S1 = <select>{::}U  = <operator1>{::}X  = <output_last>{::}|
				S1 = <select>{::}U  = <operator1>{::}X  = <output_last>{::}|
				S1 = <select>{::}U  = <operator1>{::}X  = <output_last>{::}|
				S1 = <select>{::}S2 = <select>{::}U  = <operator2>{::}X  = <output_last>{::}|
				S1 = <select>{::}S2 = <select>{::}U  = <operator2>{::}X  = <output_last>{::}|
				S1 = <select>{::}S2 = <select>{::}U  = <operator2>{::}X  = <output_last>{::}|
				S1 = <select>{::}S2 = <select>{::}S3 = <select>{::}U  = <operator3>{::}X  = <output_last>{::}

<step> ::= 	S1 = <select>{::}U = <operator1>{::}X  = <output>{::}|
				S1 = <select>{::}U = <operator1>{::}X  = <output>{::}|
				S1 = <select>{::}U = <operator1>{::}X  = <output>{::}|
				S1 = <select>{::}S2 = <select>{::}U  = <operator2>{::}X  = <output>{::}|
				S1 = <select>{::}S2 = <select>{::}U  = <operator2>{::}X  = <output>{::}|
				S1 = <select>{::}S2 = <select>{::}U  = <operator2>{::}X  = <output>{::}|
				S1 = <select>{::}S2 = <select>{::}S3 = <select>{::}U  = <operator3>{::}X  = <output>{::}

<select>    ::= <select_random>|<select_tournament>|<select_current>#|<select_roulette>
<operator1> ::= <op_pso>|<op_cs>|<op_mut_uni>
<operator2> ::= <op_crx_blend>|<op_crx_exp>|<op_crx_uni>
<operator3> ::= <op_mut_de>
<output>    ::= <update_all>|<update_best>|<update_better_than_random>|<update_later>
<output_last> ::= <update_all>|<update_best>|<update_better_than_random>
<drop>      ::= <drop_random>|<drop_worst>
<repair>    ::= <repair_random>|<repair_truncate>

#selection
<select_random>     ::= op.select_random(<X_or_U>, 1)
<select_tournament> ::= op.select_tournament(<X_or_U>, n=1, k=int(n*<parameter_percentage>))
<select_current>    ::= op.select_current(<X_or_U>)
<select_roulette>   ::= op.select_roulette(<X_or_U>)
<X_or_U> ::= X | U

#operators 1-1
<op_pso>     ::= op.w_pso(S1, w=<parameter_float>, c1=<parameter_float>, c2=<parameter_float>)
<op_cs>      ::= op.w_levy_flight(S1)
<op_mut_uni> ::= op.w_mut_uni(S1, pr=<parameter_percentage>)

#operators 2-2
<op_crx_blend> ::= op.w_crx_blend2(S1, S2, alpha=<parameter_float>)
<op_crx_exp>   ::= op.w_crx_exp2(S1, S2, pr=<parameter_percentage>)
<op_crx_uni>   ::= op.w_crx_uni2(S1, S2, pr=<parameter_percentage>)

#operators 3-1
<op_mut_de> ::= op.w_mut_de(S1, S2, S3, beta=<parameter_float>)

#output (update-rule / keep-rule)
<update_later> ::= X #apply more steps before updating
<update_all> ::= U
<update_best> ::= op.replace_if_best(X, U)
<update_better_than_random> ::= op.replace_if_random(X, U)

#drop
<drop_random> ::= X = op.drop_probability(X, pr=<parameter_percentage>){::}
<drop_worst>  ::= X = op.drop_worst(X, pr=<parameter_percentage>, k=int(n*<parameter_percentage>)) {::}

#repair
<repair_random>   ::= op.repair_random
<repair_truncate> ::= op.repair_truncate

#PARAMETERS
<parameter_int>					::= op.generate_int(min=2, max=2000)
<parameter_float>				::= op.generate_float(min=0, max=3, step=0.01)
<parameter_percentage>	::= op.generate_float(min=0, max=1, step=0.05)

#exec
<call> ::= Solution = ge(<parameter_int>, my_func, bounds, dimension, max_nfe){::}output_fitness = Solution.best.getFitness(){::}output_nfe = Solution.nfe
